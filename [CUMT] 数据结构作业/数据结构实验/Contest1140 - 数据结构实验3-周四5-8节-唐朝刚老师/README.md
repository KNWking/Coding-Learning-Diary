# 问题 A: 二叉链表存储的二叉树
## 题目描述
树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构，其形式定义如下：

```cpp
typedef struct BiTNode{
	TElemType data;
	struct BiTNode *lchild, *rchi1d;  // 左右孩子指针
}BiTNode, *BiTree;
```

而二叉树的前序、中序遍历是非常重要的能够访问二叉树所有结点的算法，下面分别列出一种先序遍历和两种中序遍历的算法。

```cpp
void PreOrderTraverse(BiTree T, Status(*Visit)(TElemType)){
/*初始条件：二叉树r存在，131t是对结点操作的应用函数。算法6.1，有改动*/
/*操作结果：先序递归遍历r,对每个结点调用函数v131t一次且仅一次*/
	if(T){  /*T不空*/
		Visit(T->data);  /*先访问根结点*/
		PreOrderTraverse(T->1 child,V1sit);  /"再先序遍历左子树*/
		PreOrderTraverse(T->rchild,Visit);  /"最后先序遍历右子树*/
	}
}
```

第一种中序遍历的方法（算法6.3）：

```cpp
Status InOrderTraversel(BiTree T, Status(*Visit)(TElemType)){
/*采用二叉链表存储结构，V131t是对数据元素操作的应用函数。算法6.3*/
/*中序遍历二叉树r的非递归算法（利用栈），对每个数据元素调用函数V131t*/
	SqStack S;
	InitStack(&S);
	while(T || !StackEmpty(S)){
		if(T){  /*根指针进栈，遍历左子树*/
		Push(&S,T);
		T=T->1child;
	}e1se{/*根指针退栈，访问根结点，遍历右子树*/
		Pop(&S, &T);
		if(!visit(T -> data))
		return ERROR;
		T = T -> rchild;
	}
	printf ("\n");
	return OK;
}
```

第二种中序遍历的方法（算法6.2）：

```cpp
Status InorderTraverse2(BiTree T,Status(*Visit)(TElemType)){
/*采用二叉链表存储结构，V131t是对数据元素操作的应用函数。算法6.2*/
/*中序遍历二叉树r的非递归算法（利用栈），对每个数据元素调用函数v131t
	SqStack S;
	BiTree p;
	InitStack(&S);
	Push(&S,T);  /*根指针进栈*/
	while(!StackEmpty(S)){
		while(GetTop(S, &p) && sp)
			Push(&S, p -> lchi1d);/向左走到尽头*/
	Pop(&S, &p);  /*空指针退栈*/
	if(!StackEmpty(s)){  /*访问结点，向右一步*/
		Pop(&S,&p);
		if(!Visit(p -> data)) return ERROR;
		Push(&S, p -> rchild);
	}
	printf("\n");
	return OK;
}
```

通过读入一个字符串，建立二叉树的算法如下：

```cpp
void CreateBiTree(BiTree *T){
/*算法6.4：按先序次序输入二叉树中结点的值（可为字符型或整型，在主程序*
/*中定义），构造二叉链表表示的二叉树红。变量N11表示空（子）树。*/
	TElemType ch;
	scanf("%c", &ch);
	if(ch == Nil){  /*空*/
		*T = NULL;
	}else{
		*T = (BiTree)malloc(sizeof(BiTNode));
		if(!*T) exit(OVERFLOW);
		(*T) -> data = ch;/*生成根结点*/
		CreateBiTree(s(*T) -> lchild);  /*构造左子树*/
		CreateBiTree(&(*T) -> rchild);  /"构造右子树*/
	}
}
```

在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。

## 输入
输入只有一行，包含一个字符串 $S$ ，用来建立二叉树。保证 $S$ 为合法的二叉树先序遍历字符串，节点内容只有大写字母，且 $S$ 的长度不超过 $100$ 。

## 输出
共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。

## 样例输入
```
ABC  DE G  F   

```

## 样例输出
```
A B C D E G F 
C B E G D F A 
C B E G D F A 

```

##提示
遍历是二叉树各种操作的基础，可以在遍历的过程中对节点进行各种操作。通过二叉树的遍历，可以建立二叉树。而先序、中序和后序遍历分别具有各自的特点，是探索二叉树性质的绝佳“武器”。

---
# 问题 B: 哈夫曼树
## 题目描述
哈夫曼树，第一行输入一个数 $n$ ，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即 $weight$ ，题目需要输出所有叶子结点的路径长度与权值的乘积之和。

## 输入
输入有多组数据。

每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2<=n<=1000）。

## 输出
输出权值。

## 样例输入
```
2
2 8 
3
5 11 30 

```

## 样例输出
```
10
62

```

---
# 问题 C: 主对角线上的数据和
## 题目描述
在一个 $N$ 行 $N$ 列的方阵 (或称 $N$ 阶方阵) 中，从左上角到右下角这一斜线上有 $N$ 个数据元素，这个斜线称为方阵的主对角线。给你一个方阵，请求方阵主对角线上数据的和。

## 输入
第一行是 $N(N<100)$ ，表示下边是一个 $N$ 阶方阵。接下来 $N$ 行 $N$ 列用空格间隔放置正整数（ $int$ 型）。

## 输出
$N$ 阶方阵主对角线上数据的和。

## 样例输入
```
3
1 2 3
1 2 3
1 2 3

```

## 样例输出
```
6

```

---
# 问题 D: 最短路径
## 题目描述
一个迷宫地图中，多个房间由单向通道相连，房间号从 $1$ 到 $N$ 依次编号。你能编程求解任意房间间的最短路径长度吗？

## 输入
第一行是迷宫中的房间数 $N$ 和单向通道数 $M(0<N,M<100)$ ，接下来 $M$ 行，每行三个数 $x,y,z$，表示一个通道是从 $x$ 到 $y$ , 且通道长度是 $z(z<1000)$ 。

最后一行是 $start$ 和 $end$ ，分别是起点房间号和终点房间号。

## 输出
输出起点房间号和终点房间号间的最短路径长度。如果没有通路，输出 `STOP`。

## 样例输入
```
7 9
1 2 3
1 3 2
3 4 2
6 3 1
2 6 3
6 7 6
2 5 4
5 4 2
5 7 5
1 7

```

## 样例输出
```
12

```

---
# 问题 E: 汉诺塔游戏中的移动
## 题目描述
有三根标为 $A$ 、 $B$ 、 $C$ 的柱子， $A$ 柱子上从上到下按金字塔状依次叠放着 $n$ 个半径从 $1$ 厘米到 $n$ 厘米的的圆盘，要把 $A$ 上的所有盘子移动到柱子 $C$ 上，中间可以临时放在 $B$ 上，但每次移动每一根柱子上都不能出现大盘子在小盘子上方的情况，要求用最少的移动次数完成，请编程模拟每次移动。

## 输入
占一行，为整数 $n(n<64)$ ，表示盘子数。

## 输出
把 $A$ 上的所有盘子移动到柱子 $C$ 上，每次只能移动一个盘子，输出移动每一次过程。每次移动占一行，第一个数表示第几步移动，第二个数是移动的盘子的半径，然后是从哪个柱子移动到哪个柱子。

## 样例输入
```
2

```

## 样例输出
```
1 1 A->B
2 2 A->C
3 1 B->C

```

---
# 问题 F: 树的先根遍历
## 题目描述
已知一颗树的节点间关系，请编程实现该树的先根遍历。

## 输入
若干行，每行描述了一组双亲节点和孩子节点的关系序偶对（每个节点用不同的大写字母表示，节点小于 $26$ 个）。且树的度小于 $5$。

## 输出
该树的先根遍历序列，序列中每个字母用空格隔开。

## 样例输入
```
B E
B F
A B
A C

```

## 样例输出
```
A B E F C

```

---
# 问题 G: 树的后根遍历
## 题目描述
已知一颗树的节点间关系，请编程实现该树的后根遍历序列。

## 输入
若干行，每行描述了一组双亲节点和孩子节点的关系序偶对（每个节点用不同的 $大写字母$ 表示，节点小于 $26$ 个）。且树的度小于 $5$。

## 输出
该树的后根遍历序列，序列中每个字母用空格隔开。

## 样例输入
```
B E
B F
A B
A C

```

## 样例输出
```
E F B C A

```
