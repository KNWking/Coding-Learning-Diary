# 问题 A: 二叉链表存储的二叉树
## 题目描述
树形结构是一类重要的非线性数据结构，其中以树和二叉树最为常用。对于每一个结点至多只有两棵子树的一类树，称其为二叉树。二叉树的链式存储结构是一类重要的数据结构，其形式定义如下：

```cpp
typedef struct BiTNode{
	TElemType data;
	struct BiTNode *lchild, *rchi1d;  // 左右孩子指针
}BiTNode, *BiTree;
```

而二叉树的前序、中序遍历是非常重要的能够访问二叉树所有结点的算法，下面分别列出一种先序遍历和两种中序遍历的算法。

```cpp
void PreOrderTraverse(BiTree T, Status(*Visit)(TElemType)){
/*初始条件：二叉树r存在，131t是对结点操作的应用函数。算法6.1，有改动*/
/*操作结果：先序递归遍历r,对每个结点调用函数v131t一次且仅一次*/
	if(T){  /*T不空*/
		Visit(T->data);  /*先访问根结点*/
		PreOrderTraverse(T->1 child,V1sit);  /*再先序遍历左子树*/
		PreOrderTraverse(T->rchild,Visit);  /*最后先序遍历右子树*/
	}
}
```

第一种中序遍历的方法（算法6.3）：

```cpp
Status InOrderTraversel(BiTree T, Status(*Visit)(TElemType)){
/*采用二叉链表存储结构，V131t是对数据元素操作的应用函数。算法6.3*/
/*中序遍历二叉树r的非递归算法（利用栈），对每个数据元素调用函数V131t*/
	SqStack S;
	InitStack(&S);
	while(T || !StackEmpty(S)){
		if(T){  /*根指针进栈，遍历左子树*/
		Push(&S,T);
		T=T->1child;
	}e1se{/*根指针退栈，访问根结点，遍历右子树*/
		Pop(&S, &T);
		if(!visit(T -> data))
		return ERROR;
		T = T -> rchild;
	}
	printf ("\n");
	return OK;
}
```

第二种中序遍历的方法（算法6.2）：

```cpp
Status InorderTraverse2(BiTree T,Status(*Visit)(TElemType)){
/*采用二叉链表存储结构，V131t是对数据元素操作的应用函数。算法6.2*/
/*中序遍历二叉树r的非递归算法（利用栈），对每个数据元素调用函数v131t
	SqStack S;
	BiTree p;
	InitStack(&S);
	Push(&S,T);  /*根指针进栈*/
	while(!StackEmpty(S)){
		while(GetTop(S, &p) && sp)
			Push(&S, p -> lchi1d);/*向左走到尽头*/
	Pop(&S, &p);  /*空指针退栈*/
	if(!StackEmpty(s)){  /*访问结点，向右一步*/
		Pop(&S,&p);
		if(!Visit(p -> data)) return ERROR;
		Push(&S, p -> rchild);
	}
	printf("\n");
	return OK;
}
```

通过读入一个字符串，建立二叉树的算法如下：

```cpp
void CreateBiTree(BiTree *T){
/*算法6.4：按先序次序输入二叉树中结点的值（可为字符型或整型，在主程序*
/*中定义），构造二叉链表表示的二叉树红。变量N11表示空（子）树。*/
	TElemType ch;
	scanf("%c", &ch);
	if(ch == Nil){  /*空*/
		*T = NULL;
	}else{
		*T = (BiTree)malloc(sizeof(BiTNode));
		if(!*T) exit(OVERFLOW);
		(*T) -> data = ch;/*生成根结点*/
		CreateBiTree(s(*T) -> lchild);  /*构造左子树*/
		CreateBiTree(&(*T) -> rchild);  /*构造右子树*/
	}
}
```

在本题中，将会给出一个按照先序遍历得出的字符串，空格代表空的子节点，大写字母代表节点内容。请通过这个字符串建立二叉树，并按照题目描述中的一种先序遍历和两种中序遍历的算法分别输出每一个非空节点。

## 输入
输入只有一行，包含一个字符串 $S$ ，用来建立二叉树。保证 $S$ 为合法的二叉树先序遍历字符串，节点内容只有大写字母，且 $S$ 的长度不超过 $100$ 。

## 输出
共有三行，每一行包含一串字符，表示分别按先序、中序、中序得出的节点内容，每个字母后输出一个空格。请注意行尾输出换行。

## 样例输入
```
ABC  DE G  F   

```

## 样例输出
```
A B C D E G F 
C B E G D F A 
C B E G D F A 

```

---
# 问题 B: 哈夫曼树
## 题目描述
哈夫曼树，第一行输入一个数 $n$ ，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即 $weight$ ，题目需要输出所有叶子结点的路径长度与权值的乘积之和。

## 输入
输入有多组数据。

每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2<=n<=1000）。

## 输出
输出权值。

## 样例输入
```
2
2 8 
3
5 11 30 

```

## 样例输出
```
10
62

```

---
# 问题 C: 树的遍历
## 题目描述
假设二叉树中的所有键值都是不同的正整数。唯一的二元树可以通过给定的后序和顺序遍历序列，或前序和顺序遍历序列来确定。但是，如果仅给出后序和前序遍历序列，则相应的树可能不再是唯一的。

现在给出一对后序和前序遍历序列，您应该输出树的相应的中序遍历序列。如果树不是唯一的，只需输出其中任何一个。

## 输入
每个输入文件包含一个测试用例。对于每种情况，第一行给出正整数 $N(\leq 30)$ ，即二叉树中的节点总数。第二行给出预订序列，第三行给出后序序列。一行中的所有数字都用空格分隔。

## 输出
对于每个测试用例，如果树是唯一的，则首先是行中的 `Yes`，否则是 `No`。然后在下一行中打印相应二叉树的中序遍历序列。如果解决方案不是唯一的，那么任何答案都可以。保证至少存在一种解决方案。一行中的所有数字必须用一个空格分隔，并且行的末尾不能有额外的空格。

## 样例输入
```
7
1 2 3 4 6 7 5
2 6 7 4 5 3 1

```

## 样例输出
```
Yes
2 1 6 4 7 3 5

```

---
# 问题 D: 最短路径
## 题目描述
一个迷宫地图中，多个房间由单向通道相连，房间号从 $1$ 到 $N$ 依次编号。你能编程求解任意房间间的最短路径长度吗？

## 输入
第一行是迷宫中的房间数 $N$ 和单向通道数 $M(0<N,M<100)$ ，接下来 $M$ 行，每行三个数 $x,y,z$，表示一个通道是从 $x$ 到 $y$ , 且通道长度是 $z(z<1000)$ 。

最后一行是 $start$ 和 $end$ ，分别是起点房间号和终点房间号。

## 输出
输出起点房间号和终点房间号间的最短路径长度。如果没有通路，输出 `STOP`。

## 样例输入
```
7 9
1 2 3
1 3 2
3 4 2
6 3 1
2 6 3
6 7 6
2 5 4
5 4 2
5 7 5
1 7

```

## 样例输出
```
12

```

---
# 问题 E: 最小生成树
## 题目描述
最小生成树问题是实际生产生活中十分重要的一类问题。假设需要在 $n$ 个城市之间建立通信联络网，则连通 $n$ 个城市只需要 $n-1$ 条线路。这时，自然需要考虑这样一个问题，即如何在最节省经费的前提下建立这个通信网。

可以用连通网来表示 $n$ 个城市以及 $n$ 个城市之间可能设置的通信线路，其中网的顶点表示城市，边表示两个城市之间的线路，赋于边的权值表示相应的代价。对于 $n$ 个顶点的连通网可以建立许多不同的生成树，每一棵生成树都可以是一个通信网。现在，需要选择一棵生成树，使总的耗费最小。这个问题就是构造连通网的最小代价生成树，简称最小生成树。一棵生成树的代价就是树上各边的代价之和。

而在常用的最小生成树构造算法中，普里姆（ $Prim$ ）算法是一种非常常用的算法。以下是其算法的大致结构：

```cpp
void MiniSpanTree_PRIM(MGraph G, VertexType u) {  // 算法7.9
    // 用普里姆算法从输入的n个顶点出发构造图G的最小生成树，输出T的各条边。
    // 记录从顶点集合U到V-U的代价最小的边的辅助数组定义
    // struct {
    //     VertexType adjvex;
    //     VRType lowcost;
    // } closedge[MAX_VERTEX_NUM];
    int i,j,k;
    k = LocateVex ( G, u );
    for ( j=0; j<G.vexnum; ++j ){  // 辅助数组初始化
        if ( j != k ) {
            closedge[j].adjvex=u; 
            closedge[j].lowcost=G.arcs[k][j].adj;
        }
    }
    closedge[k].lowcost = 0;  // 初始，U = {u}
    for ( i=1; i<G.vexnum; ++i ) {  // 选择其余G.vexnum-1个顶点
        k = Minimum ( closedge );  // 求出T的下一个结点，第k顶点
        // 此时 closedge[k].lowcost =
        // MIN{closedge[vi].lowcost | closedge[vi].lowcost > 0, vi ∈ V - U}
        printf ( "(%d,%d)",closedge[k].adjvex, G.vexs[k] );  // 输出生成树的边
        closedge[k].lowcost = 0;  // 第 k 顶点并入U集
        for ( j=0; j<G.vexnum; ++j )
            if ( G.arcs[k][j].adj<closedge[j].lowcost ) {
            // 新顶点并入U后重新选择最小边
            // closedge[j] = {G.vexs[k], G.arcs[k][j].adj};
                closedge[j].adjvex=G.vexs[k];
                closedge[j].lowcost=G.arcs[k][j].adj;
            }
    }
} // MiniSpanTree
```

在本题中，读入一个无向图的邻接矩阵（即数组表示），建立无向图并按照以上描述中的算法建立最小生成树，并输出最小生成树的代价。

## 输入
输入的第一行包含一个正整数 $n$ ，表示图中共有 $n$ 个顶点。其中 $n$ 不超过 $50$。

以后的 $n$ 行中每行有 $n$ 个用空格隔开的整数，对于第 $i$ 行的第 $j$ 个整数，如果不为 $0$ ，则表示第 $i$ 个顶点和第 $j$ 个顶点有直接连接且代价为相应的值， $0$ 表示没有直接连接。当 $i$ 和 $j$ 相等的时候，保证对应的整数为 $0$ 。

输入保证邻接矩阵为对称矩阵，即输入的图一定是无向图，且保证图中只有一个连通分量。

## 输出
只有一个整数，即最小生成树的总代价。请注意行尾输出换行。

## 样例输入
```
4
0 2 4 0
2 0 3 5
4 3 0 1
0 5 1 0

```

## 样例输出
```
6

```
